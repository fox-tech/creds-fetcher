package okta

import (
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"net/url"
	"time"
)

// accessToken represents a succesful response from Okta's oauth2/v1/token
// endpoint.
type accessToken struct {
	TokenType    string `json:"token_type"`
	ExpiresIn    int64  `json:"expires_in"`
	AccessToken  string `json:"access_token"`
	Scope        string `json:"scope"`
	RefreshToken string `json:"refresh_token"`
	IDToken      string `json:"id_token"`
}

// ErrDeviceAuthorizationExpired is returned when the Device Authorization
// credentials expired. In this case, the PreAuthorize has to be run again and
// the user will be provided with a new verification URL.
var ErrDeviceAuthorizationExpired = errors.New("device authorization expired")

// accessTokenPoll returns a valid OAuth2 accessToken on a succesful device
// code authorization exchange. Returns non-nil error in case of the Device
// authorization expiring, in case the HTTP request receives an HTTP status
// code different to http.StatusOK/http.StatusBadRequest or on a JSON decoding
// failure.
func (c Client) accessTokenPoll(device Device) (accessToken, error) {
	tick := time.NewTicker(time.Duration(device.Interval) * time.Second)
	defer tick.Stop()

	timeout := time.After(time.Duration(device.ExpiresIn+1) * time.Second)

	for {
		select {
		case <-timeout:
			return accessToken{}, ErrDeviceAuthorizationExpired
		case <-tick.C:
			token, err := c.accessTokenRequest(device)
			if err != nil {
				return accessToken{}, err
			}

			if token.AccessToken != "" {
				return token, nil
			}
		}
	}
}

// ErrAccessTokenRequest is returned when the server fails to fulfill the
// device code authorization exchange request or the response is different to
// http.StatusOK and http.StatusBadRequest.
var ErrAccessTokenRequest = errors.New("accessToken request")

// ErrAccessTokenJSONDecode is returned when the JSON response from the device
// code authorization exchange can't be properly decoded.
var ErrAccessTokenJSONDecode = errors.New("json decode")

// accessTokenRequest returns the OAuth2 token from a device code grant.
// Returns non-nil error in case of the request failing with an HTTP status
// code different to http.StatusOK/http.StatusBadRequest or in case the JSON
// response failed to be decoded.
func (c Client) accessTokenRequest(device Device) (accessToken, error) {
	uri := fmt.Sprintf("%s/oauth2/v1/token", c.uri)
	resp, err := http.PostForm(uri,
		url.Values{
			"client_id":   []string{c.id},
			"device_code": []string{device.DeviceCode},
			"grant_type":  []string{"urn:ietf:params:oauth:grant-type:device_code"},
		},
	)
	if err != nil {
		return accessToken{}, fmt.Errorf("%w: %v", ErrAccessTokenRequest, err)
	}
	defer resp.Body.Close()

	if resp.StatusCode == http.StatusBadRequest {
		return accessToken{}, nil
	}

	if resp.StatusCode != http.StatusOK {
		var errRes errorResponse
		if err := json.NewDecoder(resp.Body).Decode(&errRes); err != nil {
			return accessToken{}, fmt.Errorf("%w: error response %v", ErrAccessTokenJSONDecode, err)
		}

		return accessToken{}, fmt.Errorf("%w: statusCode %d/%s: %s", ErrAccessTokenRequest, resp.StatusCode, errRes.Error, errRes.Description)
	}

	var token accessToken
	if err := json.NewDecoder(resp.Body).Decode(&token); err != nil {
		return token, fmt.Errorf("%w: %v", ErrAccessTokenJSONDecode, err)
	}

	return token, nil
}

// ErrSSOJSONDecode is returned when the response for the web SSO token can't
// be decoded into JSON.
var ErrSSOJSONDecode = errors.New("sso json decode")

// ErrSSORequest is returned when the server fails to fulfill the SSO token
// request or the response is different to http.StatusOK.
var ErrSSORequest = errors.New("sso request")

// ssoAccessToken returns an SSO token exchanged from the OAuth2 token
// generated by the user's explicit authorization.
//
// More at https://developer.okta.com/docs/guides/configure-native-sso/-/main/.
func (c Client) ssoAccessToken(token accessToken) (accessToken, error) {
	uri := fmt.Sprintf("%s/oauth2/v1/token", c.uri)
	resp, err := http.PostForm(uri,
		url.Values{
			"client_id":            []string{c.id},
			"actor_token":          []string{token.AccessToken},
			"actor_token_type":     []string{"urn:ietf:params:oauth:token-type:access_token"},
			"subject_token":        []string{token.IDToken},
			"subject_token_type":   []string{"urn:ietf:params:oauth:token-type:id_token"},
			"requested_token_type": []string{"urn:okta:oauth:token-type:web_sso_token"},
			"audience":             []string{"urn:okta:apps:" + c.appID},
			"grant_type":           []string{"urn:ietf:params:oauth:grant-type:token-exchange"},
		},
	)
	if err != nil {
		return accessToken{}, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		var errRes errorResponse
		if err := json.NewDecoder(resp.Body).Decode(&errRes); err != nil {
			return accessToken{}, fmt.Errorf("%w: %v", ErrSSOJSONDecode, err)
		}

		return accessToken{}, fmt.Errorf("%w: statusCode %d/%s, %s", ErrSSORequest, resp.StatusCode, errRes.Error, errRes.Description)
	}

	var sso accessToken
	if err := json.NewDecoder(resp.Body).Decode(&sso); err != nil {
		return sso, fmt.Errorf("%w: %v", ErrSSOJSONDecode, err)
	}

	return sso, err
}
